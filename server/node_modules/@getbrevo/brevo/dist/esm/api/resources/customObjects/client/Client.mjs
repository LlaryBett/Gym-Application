// This file was auto-generated by Fern from our API Definition.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { normalizeClientOptionsWithAuth } from "../../../../BaseClient.mjs";
import { mergeHeaders } from "../../../../core/headers.mjs";
import * as core from "../../../../core/index.mjs";
import * as environments from "../../../../environments.mjs";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.mjs";
import * as errors from "../../../../errors/index.mjs";
import * as Brevo from "../../../index.mjs";
export class CustomObjectsClient {
    constructor(options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }
    /**
     * <Note title="Enterprise access only">
     * Custom objects are only available to Enterprise plans.
     *
     * This feature is in beta. These are subject to change.
     * </Note>
     *
     * This API allows bulk upsert of object records in a single request. Each object record may include
     *   - Attributes
     *   - Identifiers
     *   - Associations
     * **Response:**
     *   The API processes the request asynchronously and returns a processId that you can use to track the background process status.
     * **API and Schema Limitation:**
     *   - Size:
     *       - Max 1000 objects records per request
     *       - Max request body size: 1 MB
     *   - Max 500 attributes defined per object record upsert request
     *     - This is coherent with schema limitation: an object cannot have more than 500 attributes.
     *     - Worth noting: Nothing happens If an attribute is mentioned in the request, but was not previously defined for the object schema (no error, no attribute creation)
     *   - Max 10 associations defined per object record upsert request
     *     - This is coherent with schema limitation: an object cannot have more than 10 associations with other objects. and each object record can be linked to max 10 other records.
     * **Errors:**
     *     - Make sure both object records exist before associating them, else the API will return an error.
     *     - This route does not create objects. The object where the object records are upserted by this API must be created already else the API will return an error "invalid object type".
     *
     * @param {Brevo.UpsertrecordsRequest} request
     * @param {CustomObjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.ForbiddenError}
     * @throws {@link Brevo.NotFoundError}
     * @throws {@link Brevo.InternalServerError}
     *
     * @example
     *     await client.customObjects.upsertrecords({
     *         object_type: "vehicle",
     *         records: [{}]
     *     })
     */
    upsertrecords(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__upsertrecords(request, requestOptions));
    }
    __upsertrecords(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { object_type: objectType } = request, _body = __rest(request, ["object_type"]);
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `objects/${core.url.encodePathParam(objectType)}/batch/upsert`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: _body,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Brevo.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new Brevo.InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/objects/{object_type}/batch/upsert");
        });
    }
    /**
     * <Note title="Enterprise access only">
     * Custom objects are only available to Enterprise plans.
     *
     * This feature is in beta. These are subject to change.
     * </Note>
     *
     * This API retrieves a list of object records along with their associated records and provides the total count of records for the specified object. **Note**: Contact as object type is not supported in this endpoint.
     *
     * @param {Brevo.GetrecordsRequest} request
     * @param {CustomObjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.ForbiddenError}
     * @throws {@link Brevo.FailedDependencyError}
     * @throws {@link Brevo.InternalServerError}
     *
     * @example
     *     await client.customObjects.getrecords({
     *         object_type: "vehicle",
     *         limit: 1000000,
     *         page_num: 1000000
     *     })
     */
    getrecords(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getrecords(request, requestOptions));
    }
    __getrecords(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { object_type: objectType, limit, page_num: pageNum, sort, association } = request;
            const _queryParams = {
                limit,
                page_num: pageNum,
                sort: sort != null ? sort : undefined,
                association: association != null ? association : undefined,
            };
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `objects/${core.url.encodePathParam(objectType)}/records`),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Brevo.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 424:
                        throw new Brevo.FailedDependencyError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new Brevo.InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/objects/{object_type}/records");
        });
    }
    /**
     * Use this endpoint to delete multiple object records of the same object-type in one request.
     * The request is accepted and processed asynchronously.   You can track the status of the deletion process using the returned **processId**.
     * **API and Schema Limitations:** - Each request can contain up to **1000** object record identifiers   - If more records must be deleted â†’ send multiple batch requests
     *
     * @param {Brevo.BatchDeleteObjectRecordsRequest} request
     * @param {CustomObjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.ForbiddenError}
     * @throws {@link Brevo.NotFoundError}
     * @throws {@link Brevo.InternalServerError}
     *
     * @example
     *     await client.customObjects.batchDeleteObjectRecords({
     *         object_type: "vehicle",
     *         identifiers: {
     *             ext_ids: ["ext-001", "ext-002"]
     *         }
     *     })
     */
    batchDeleteObjectRecords(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__batchDeleteObjectRecords(request, requestOptions));
    }
    __batchDeleteObjectRecords(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { object_type: objectType } = request, _body = __rest(request, ["object_type"]);
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `objects/${core.url.encodePathParam(objectType)}/batch/delete`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: _body,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return {
                    data: _response.body,
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 403:
                        throw new Brevo.ForbiddenError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new Brevo.InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/objects/{object_type}/batch/delete");
        });
    }
}
