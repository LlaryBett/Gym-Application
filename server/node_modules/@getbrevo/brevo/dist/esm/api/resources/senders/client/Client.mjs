// This file was auto-generated by Fern from our API Definition.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { normalizeClientOptionsWithAuth } from "../../../../BaseClient.mjs";
import { mergeHeaders } from "../../../../core/headers.mjs";
import * as core from "../../../../core/index.mjs";
import * as environments from "../../../../environments.mjs";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.mjs";
import * as errors from "../../../../errors/index.mjs";
import * as Brevo from "../../../index.mjs";
export class SendersClient {
    constructor(options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }
    /**
     * Retrieves a list of all email senders from your Brevo account with optional filtering.
     *
     * **Use this to:**
     * - Get all available senders for email campaign setup
     * - Find sender details including ID, name, and email address
     * - Filter senders by IP address for dedicated IP users
     * - Filter senders by domain for domain-specific configurations
     * - Monitor sender configuration and status
     *
     * **Key information returned:**
     * - Sender details (ID, name, email address)
     * - Sender status and verification information
     * - Associated IP addresses and domains (for dedicated IP accounts)
     * - Sender configuration settings
     *
     * **Important considerations:**
     * - Standard accounts show empty IP arrays, dedicated IP accounts show IP assignments
     * - Filtering by IP only available for accounts with dedicated IPs
     * - Domain filtering helps organize senders by business units or brands
     * - Sender status indicates if sender is active and ready for campaign use
     * - Email verification required before sender can be used in campaigns
     *
     * @param {Brevo.GetSendersRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     *
     * @example
     *     await client.senders.getSenders()
     */
    getSenders(request = {}, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getSenders(request, requestOptions));
    }
    __getSenders() {
        return __awaiter(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { ip, domain } = request;
            const _queryParams = {
                ip,
                domain,
            };
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, "senders"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/senders");
        });
    }
    /**
     * Creates a new email sender in your Brevo account.
     *
     * **Use this to:**
     * - Add new senders for email campaigns
     * - Configure sender identity (name and email)
     * - Associate dedicated IPs with the sender (for dedicated IP accounts)
     * - Set up domain-based sender configurations
     *
     * **Key information returned:**
     * - Created sender ID
     * - DKIM and SPF configuration status
     * - Success confirmation
     *
     * **Important considerations:**
     * - Verification email sent to specified sender address
     * - DKIM and SPF configuration affects deliverability
     * - Dedicated IP accounts require IP association during creation
     * - IP weights must sum to 100 when specified
     * - Sender must be verified before use in campaigns
     *
     * @param {Brevo.CreateSenderRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     *
     * @example
     *     await client.senders.createSender({
     *         email: "support@example.com",
     *         name: "Support Team"
     *     })
     *
     * @example
     *     await client.senders.createSender({
     *         email: "marketing@example.com",
     *         ips: [{
     *                 domain: "example.com",
     *                 ip: "203.0.113.100",
     *                 weight: 100
     *             }],
     *         name: "Marketing Team"
     *     })
     *
     * @example
     *     await client.senders.createSender({
     *         email: "newsletter@example.com",
     *         ips: [{
     *                 domain: "example.com",
     *                 ip: "203.0.113.100",
     *                 weight: 60
     *             }, {
     *                 domain: "news.example.com",
     *                 ip: "203.0.113.101",
     *                 weight: 40
     *             }],
     *         name: "Newsletter"
     *     })
     */
    createSender(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__createSender(request, requestOptions));
    }
    __createSender(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, "senders"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/senders");
        });
    }
    /**
     * Retrieves all dedicated IPs associated with your Brevo account.
     *
     * Use this to:
     * - List all your dedicated IPs
     * - Check the status of your dedicated IPs (active/inactive)
     * - Find IP addresses and associated domains for configuration purposes
     * - Monitor your IP reputation and deliverability
     * - Verify available IPs for sender configuration
     *
     * Key information returned:
     * - IP ID and address
     * - Associated domain
     * - Active status
     * - IP configuration details
     *
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     *
     * @example
     *     await client.senders.getIps()
     */
    getIps(requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getIps(requestOptions));
    }
    __getIps(requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, "senders/ips"),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/senders/ips");
        });
    }
    /**
     * Updates an existing email sender's configuration.
     *
     * Use this to:
     * - Modify sender display name or email address
     * - Update dedicated IP associations
     * - Change sender configuration settings
     * - Correct sender information
     *
     * Key information returned:
     * - Success confirmation
     * - Updated sender details
     *
     * @param {Brevo.UpdateSenderRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.NotFoundError}
     *
     * @example
     *     await client.senders.updateSender({
     *         senderId: 1000000,
     *         name: "New Support Team"
     *     })
     *
     * @example
     *     await client.senders.updateSender({
     *         senderId: 1000000,
     *         email: "newsupport@mycompany.com"
     *     })
     *
     * @example
     *     await client.senders.updateSender({
     *         senderId: 1000000,
     *         email: "marketing@mycompany.com",
     *         name: "Marketing Team"
     *     })
     *
     * @example
     *     await client.senders.updateSender({
     *         senderId: 1000000,
     *         email: "marketing@enterprise.com",
     *         ips: [{
     *                 domain: "enterprise.com",
     *                 ip: "192.168.1.100",
     *                 weight: 100
     *             }],
     *         name: "Enterprise Marketing"
     *     })
     *
     * @example
     *     await client.senders.updateSender({
     *         senderId: 1000000,
     *         email: "campaigns@enterprise.com",
     *         ips: [{
     *                 domain: "enterprise.com",
     *                 ip: "192.168.1.100",
     *                 weight: 70
     *             }, {
     *                 domain: "mail.enterprise.com",
     *                 ip: "192.168.1.101",
     *                 weight: 30
     *             }],
     *         name: "Multi-IP Sender"
     *     })
     */
    updateSender(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__updateSender(request, requestOptions));
    }
    __updateSender(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { senderId } = request, _body = __rest(request, ["senderId"]);
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `senders/${core.url.encodePathParam(senderId)}`),
                method: "PUT",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: _body,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/senders/{senderId}");
        });
    }
    /**
     * Deletes an email sender from your Brevo account.
     *
     * Use this to:
     * - Remove senders that are no longer needed
     * - Clean up sender configurations
     * - Remove duplicate or test senders
     *
     * Key information returned:
     * - Success confirmation message
     *
     * @param {Brevo.DeleteSenderRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.NotFoundError}
     *
     * @example
     *     await client.senders.deleteSender({
     *         senderId: 1000000
     *     })
     */
    deleteSender(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__deleteSender(request, requestOptions));
    }
    __deleteSender(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { senderId } = request;
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `senders/${core.url.encodePathParam(senderId)}`),
                method: "DELETE",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/senders/{senderId}");
        });
    }
    /**
     * Retrieves the dedicated IPs associated with a specific sender.
     *
     * Use this to:
     * - Check IP configuration for a sender
     * - Verify dedicated IP associations
     * - Get IP details for troubleshooting
     * - Monitor sender IP configuration
     *
     * Key information returned:
     * - List of associated dedicated IPs
     * - IP addresses and domain configurations
     * - IP status and settings
     *
     * @param {Brevo.GetIpsFromSenderRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.NotFoundError}
     *
     * @example
     *     await client.senders.getIpsFromSender({
     *         senderId: 1000000
     *     })
     */
    getIpsFromSender(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__getIpsFromSender(request, requestOptions));
    }
    __getIpsFromSender(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { senderId } = request;
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `senders/${core.url.encodePathParam(senderId)}/ips`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/senders/{senderId}/ips");
        });
    }
    /**
     * Validates a sender using the OTP (One-Time Password) received via email.
     *
     * Use this to:
     * - Complete sender verification process
     * - Activate a newly created sender
     * - Verify ownership of the sender email address
     * - Enable the sender for use in email campaigns
     *
     * Key information returned:
     * - Success confirmation of sender verification
     * - Sender activation status
     *
     * @param {Brevo.ValidateSenderByOtpRequest} request
     * @param {SendersClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Brevo.BadRequestError}
     * @throws {@link Brevo.NotFoundError}
     *
     * @example
     *     await client.senders.validateSenderByOtp({
     *         senderId: 1000000,
     *         otp: 123456
     *     })
     *
     * @example
     *     await client.senders.validateSenderByOtp({
     *         senderId: 1000000,
     *         otp: 789012
     *     })
     */
    validateSenderByOtp(request, requestOptions) {
        return core.HttpResponsePromise.fromPromise(this.__validateSenderByOtp(request, requestOptions));
    }
    __validateSenderByOtp(request, requestOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const { senderId } = request, _body = __rest(request, ["senderId"]);
            const _authRequest = yield this._options.authProvider.getAuthRequest();
            const _headers = mergeHeaders(_authRequest.headers, (_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield core.fetcher({
                url: core.url.join((_c = (_b = (yield core.Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield core.Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : environments.BrevoEnvironment.Default, `senders/${core.url.encodePathParam(senderId)}/validate`),
                method: "PUT",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: _body,
                timeoutMs: ((_f = (_d = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) !== null && _d !== void 0 ? _d : (_e = this._options) === null || _e === void 0 ? void 0 : _e.timeoutInSeconds) !== null && _f !== void 0 ? _f : 60) * 1000,
                maxRetries: (_g = requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries) !== null && _g !== void 0 ? _g : (_h = this._options) === null || _h === void 0 ? void 0 : _h.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
                fetchFn: (_j = this._options) === null || _j === void 0 ? void 0 : _j.fetch,
                logging: this._options.logging,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new Brevo.BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new Brevo.NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new errors.BrevoError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/senders/{senderId}/validate");
        });
    }
}
