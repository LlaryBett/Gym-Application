import type * as Brevo from "../../../index.js";
export interface GetLoyaltyOfferProgramsPidRewardsRidResponse {
    /** Maximum number of times a consumer can be attributed this reward */
    attributionPerConsumer?: number;
    /** Unique identifier for the balance definition */
    balanceDefinitionId?: string;
    /** Unique code for the reward */
    code?: string;
    /** Total number of codes generated */
    codeCount?: number;
    /** Unique identifier for the code generator */
    codeGeneratorId?: string;
    /** Unique identifier for the code pool */
    codePoolId?: string;
    /** Configuration settings for the reward */
    config?: string;
    /** Timestamp when the reward was created */
    createdAt?: string;
    /** Disabled date of the reward */
    disabledAt?: string;
    /** End date of the reward validity */
    endDate?: string;
    /** Expiration date of the reward */
    expirationDate?: string;
    /** Select startOfPeriod to configure rewards expiry on start of day/week/month/year. Select endOfPeriod to configure reward expiry on end of day/week/month/year, else select noModification */
    expirationModifier?: GetLoyaltyOfferProgramsPidRewardsRidResponse.ExpirationModifier;
    /** Unit of time for the rewards's availability (e.g., day/week/month/year). */
    expirationUnit?: string;
    /** Number of days/weeks/month/year for reward expiry */
    expirationValue?: number;
    /** object */
    generator?: GetLoyaltyOfferProgramsPidRewardsRidResponse.Generator;
    /** Unique identifier for the reward */
    id?: string;
    /** Attribution / Redeem Limits for the reward */
    limits?: GetLoyaltyOfferProgramsPidRewardsRidResponse.Limits.Item[];
    /** Id of the loyalty program to which the current reward belongs to */
    loyaltyProgramId?: string;
    /** Additional data for reward definition */
    meta?: Record<string, unknown>;
    /** Name of the reward */
    name?: string;
    /** Selected products for reward definition */
    products?: GetLoyaltyOfferProgramsPidRewardsRidResponse.Products.Item[];
    /** Public description for the reward */
    publicDescription?: string;
    /** Public Image for the reward */
    publicImage?: string;
    /** Public name for the reward */
    publicName?: string;
    /** Defines the redeem limit for the consumer */
    redeemPerConsumer?: number;
    /** Rules defined to redeem a reward */
    redeemRules?: string[];
    /** object */
    rewardConfigs?: GetLoyaltyOfferProgramsPidRewardsRidResponse.RewardConfigs;
    /** Rule to define the reward */
    rule?: GetLoyaltyOfferProgramsPidRewardsRidResponse.Rule;
    /** Start date of attribution of the reward */
    startDate?: string;
    /** Id of the selected balance while redeeming / attributing a reward */
    subtractBalanceDefinitionId?: string;
    /** Strategy of the Balance while redeeming / attributing a reward */
    subtractBalanceStrategy?: string;
    /** Amount of balance to be selected while redeeming / attributing a reward */
    subtractBalanceValue?: number;
    /** Value to indicate to subtract full balance or not */
    subtractTotalBalance?: boolean;
    /** Defines the limit to which a consumer can attribute a reward */
    totalAttribution?: number;
    /** Defines the limit to which a consumer can redeem a reward */
    totalRedeem?: number;
    /** Id of the Rule to be updated for that reward */
    triggerId?: string;
    /** Selected unit of the balance */
    unit?: string;
    /** Timestamp for when this reward was last updated. */
    updatedAt?: string;
    /** Value of metric in selected config for reward definition */
    value?: number;
    /** Type of config selected for reward definition */
    valueType?: string;
}
export declare namespace GetLoyaltyOfferProgramsPidRewardsRidResponse {
    /** Select startOfPeriod to configure rewards expiry on start of day/week/month/year. Select endOfPeriod to configure reward expiry on end of day/week/month/year, else select noModification */
    const ExpirationModifier: {
        readonly StartOfPeriod: "startOfPeriod";
        readonly EndOfPeriod: "endOfPeriod";
        readonly NoModification: "noModification";
    };
    type ExpirationModifier = (typeof ExpirationModifier)[keyof typeof ExpirationModifier];
    interface Generator {
        /** Timestamp when the reward was created */
        createdAt?: string;
        /** Public facing description of the reward */
        description?: string;
        /** Unique identifier for the reward */
        id?: string;
        /** Name of the reward */
        name?: string;
        /** Generated pattern */
        pattern?: string;
        /** Timestamp when the reward was created */
        updatedAt?: string;
    }
    type Limits = Limits.Item[];
    namespace Limits {
        interface Item {
            /** Timestamp when the reward limit was created */
            createdAt?: string;
            /** Unit of time for the reward limit's availability (e.g., day/week/month/year). */
            durationUnit?: string;
            /** Number of days/weeks/month/year for reward limit */
            durationValue?: number;
            /** Value of the limit */
            limitValue?: number;
            /** Unique identifier for the reward limit */
            rewardLimitId?: string;
            /** Select true to calculate all redeems/attributions from the previous value of selected durationUnit to the current time */
            slidingSchedule?: boolean;
            /** Type of reward */
            type?: string;
            /** Timestamp when the reward limit was created */
            updatedAt?: string;
        }
    }
    type Products = Products.Item[];
    namespace Products {
        interface Item {
            /** Timestamp when the product was created */
            createdAt?: string;
            /** URL of the product image */
            imageRef?: string;
            /** Unique identifier for the product */
            productId?: string;
            /** string */
            value?: string;
        }
    }
    interface RewardConfigs {
        /** Attribution config of the reward */
        attribution?: string;
        /** Code config of the reward */
        code?: string;
        /** Value config of the reward */
        value?: string;
    }
    interface Rule {
        /** Selected rule condition */
        condition?: Brevo.RuleConditionResponse;
        /** Timestamp when the rule was created */
        createdAt?: string;
        /** Description of the rule */
        description?: string;
        /** Selected event in the rule */
        event?: Rule.Event;
        /** Metric to identify if it's an internal rule or not */
        isInternal?: boolean;
        /** Loyalty Program id to which current rule is associated */
        loyaltyProgramId?: string;
        /** Loyalty Version id to which current rule is associated */
        loyaltyVersionId?: number;
        /** Additional data to define the rule */
        meta?: Record<string, unknown>;
        /** Rule name */
        name?: string;
        /** Results of the rule definition */
        results?: Rule.Results.Item[];
        /** Unique identifier for the rule */
        ruleId?: string;
        /** Type of the rule */
        ruleType?: string;
        /** Timestamp when the rule was updated */
        updatedAt?: string;
    }
    namespace Rule {
        interface Event {
            /** Name of the event */
            name?: string;
            /** Source of the event */
            source?: string;
        }
        type Results = Results.Item[];
        namespace Results {
            interface Item {
                /** Action for the defined rule */
                action?: string;
                /** Parameters to define the reward */
                parameters?: Item.Parameters.Item[];
                /** Selected service to define the reward */
                service?: string;
            }
            namespace Item {
                type Parameters = Parameters.Item[];
                namespace Parameters {
                    interface Item {
                        /** Name of the rule */
                        name?: string;
                        /** Selected value of the parameter to define the rule */
                        value?: Brevo.ValueResponse;
                    }
                }
            }
        }
    }
}
